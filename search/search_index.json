{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Welcome to documentation for Baj's Tower Defense Framework!</p>"},{"location":"#project-description","title":"Project Description","text":"<p>Baj's Tower Defense Framework (jTDF) is an open source framework, designed to make creation of Tower Defense games on Roblox easier.</p> <p>jTDF handles:</p> <ul> <li>Towers: stats, placement, upgrades</li> <li>Enemies: health, speed, death</li> <li>Enemy detection: easily create enemy detection radii with no concern for performance</li> <li>Paths</li> <li>API endpoints</li> </ul> <p>what jTDF does NOT handle:</p> <ul> <li>Game logic</li> <li>Rendering</li> <li>Anything client side</li> </ul>"},{"location":"#why-choose-us","title":"Why choose us?","text":""},{"location":"#ease-of-use","title":"Ease of use","text":"<p>When trying to learn new frameworks, beginner developers often get confused, frustrated, and don't understand how to create exactly what they want.</p> <p>jTDF solves that by providing a comprehensible documentation and keeping functions clean and understandable.</p>"},{"location":"#performance","title":"Performance","text":"<p>jTDF optimizes all internal heavy tasks with parallel luau without restricting developer freedom.</p> <p>Math and checks happen on server, rendering and animation happen on client.</p>"},{"location":"#customization","title":"Customization","text":"<p>All functions and data structures are built in a way which allows for their dynamic modification. jTDF assumes nothing about your game, except that it's a tower defense. You are free to do everything in your own way.</p>"},{"location":"#security","title":"Security","text":"<p>jTDF is a server tool, it does not handle user input.</p> <p>That being said, important functions are secured with <code>t</code> module type checking.</p> <p>In API reference you will see a note under functions that use <code>t</code>.</p>"},{"location":"#games-using-jtdf","title":"Games using jTDF","text":"<p>If your game uses jTDF and you want to be added to this page, you can dm me in Discord (@bajsucks) or ping me on the jTDF community server.</p>"},{"location":"Configuration/","title":"Configuration","text":""},{"location":"Configuration/#config-module-parameters","title":"Config module parameters","text":"<p>Currently the config module only has 1 parameter, but it will be expanded in future updates.</p> <pre><code>BootText: boolean\n</code></pre> <p>Determines whether the text <code>Running jTDF {Version}</code> will be displayed on server after module is initialized.</p>"},{"location":"Demoplace/","title":"Demo place","text":"<p>There is a demo place that showcases how to create basic logic and functionality using jTDF</p> <p>You can find it on this roblox page. The game is uncopylocked.</p> <p>Features implemented in the demo place:</p> <ul> <li>Enemy rendering</li> <li>Tower upgrades</li> <li>Example enemy path</li> <li>Data replication</li> <li>Example implementation of several tower types (solo, burst, multi enemy, freeze, etc.)</li> </ul>"},{"location":"Installation/","title":"Installation","text":"<p>You can download jTDF from the following places:</p> <ul> <li> <p>Creator Hub</p> </li> <li> <p>Github releases</p> </li> </ul> <p>It is recommended to parent jTDF to <code>ReplicatedStorage</code> so the client is able to import jTDF types, although it will work correctly when parented anywhere else too.</p> <p>When required on server, jTDF will create a folder <code>jTDF_Actors</code> in <code>ServerScriptService</code>. This folder is used to store actors for parallelization; Do not touch it!</p> <p>jTDF module has tag <code>_JTDFMODULE</code>, which is used in actors to find it's location. Do not remove it! If you got the module from source, do not forget to add that tag!</p>"},{"location":"Notes/","title":"Other information","text":""},{"location":"Notes/#contributing","title":"Contributing","text":"<p>You can contribute to the project or this documentation by opening a github pull request</p>"},{"location":"Notes/#feedback-and-support","title":"Feedback and support","text":"<p>If you want to share your feedback, suggestions or need help with usage of the framework, you can do it on:</p> <ul> <li> <p>Devforum page</p> </li> <li> <p>Discord community server</p> </li> </ul>"},{"location":"Notes/#path-creation","title":"Path creation","text":"<p>Paths are a series of attachments that enemies follow, creating a linear path with a clear beginning and end.</p> <p>For an attachment to be considered part of a path, it has to have those properties:</p> <ul> <li><code>EnemyPath</code> tag</li> <li><code>PathID</code> attribute containing a number that will be this attachment's order on the path. It is recommended that all PathIDs are sequential, e.g. <code>1</code> <code>2</code> <code>3</code>, but should work even when they are non-sequential, e.g. <code>10</code> <code>15</code> <code>16</code> <code>23</code>.</li> <li><code>pathLabel</code> attribute containing the name of the path this attachment belongs to</li> </ul>"},{"location":"Notes/#radii-throttle","title":"Radii throttle","text":"<p>When a radius does not have enemies close, it will slow down it's update rate to once every 5 frames.</p> <p>However, when a new enemy is created, radius will instantly wake up from the throttle. That is to ensure radii work correctly when they contain an enemy spawn location within themselves.</p> <p>If you wish to manually wake a radius up from throttle, use the .Update signal.</p>"},{"location":"Path%20Builder/","title":"Path Builder","text":"<p>TBD</p>"},{"location":"jTDF/","title":"API Reference","text":""},{"location":"jTDF/#types","title":"Types","text":""},{"location":"jTDF/#ctower","title":"CTower","text":"<p>Warning</p> <p>Objects of this type are read-only. Use the constructor</p> <pre><code>{\n    [\"Name\"]: string, -- Visual name of the tower. Not used by jTDF\n    [\"Upgrades\"]: { -- Upgrades of the unit; When spawned, unit will have level 1\n        [number]: CTowerStats -- Stats that the unit will have when it reaches that upgrade\n    }\n}\n</code></pre>"},{"location":"jTDF/#ctowerstats","title":"CTowerStats","text":"<p>Warning</p> <p>Objects of this type are read-only. Use the constructor</p> <pre><code>{\n    [\"Range\"]: number?, -- Range of the tower, in studs\n    [\"FireFunction\"]: (self:Radius, Unit:Unit, Targets: {Enemy}) -&gt; (),\n    --[[    \n            Function that fires at enemies. Here you damage the enemies and apply cooldowns. This will be the main source of logic for your tower.\n            It would also make sense to fire Unit.Shot signal here, if you're using it.\n            NOTE: Sometimes, when a lot of towers fire at the same enemy and it dies, it will disappear from Targets,\n            and units with MaxLockedTargets = 1 will still call the fire function.\n            Thus, it is recommended to use for loops to damage enemies instead of directly referencing Targets[1],\n            even for towers that can only damage a single enemy at a time.\n    ]]\n    [\"CheckFunction\"]: (self:Unit) -&gt; boolean,\n    --[[\n            Function that checks if the tower is ready to fire. Return true if tower is ready, and false if it's not.\n    ]]\n    [\"RadiusConfig\"]: { -- Configuration for the radius that the tower will use\n        [\"IsPassive\"]: boolean, -- Determines whether this tower has a radius. If true, properties below will be ignored.\n        [\"CanLock\"]: boolean, -- Whether the tower locks onto enemies, or grabs the first enemy in it's radius. True for lock, false for first enemy.\n        [\"MaxLockedTargets\"]: number, -- Maximum amount of targets a tower can have. Applies to both lockable and not lockable towers, despite the name.\n        [\"TargetType\"]: number, -- TargetType of this Radius.\n        --[[\n            Target types:\n            1: First\n            2: Closest (not yet implemented!)\n        ]]\n    }\n}\n</code></pre>"},{"location":"jTDF/#cenemy","title":"CEnemy","text":"<p>Warning</p> <p>Objects of this type are read-only. Use the constructor</p> <pre><code>{\n    [\"Name\"]: string, -- Visual name of the enemy. Not used by jTDF\n    [\"BaseHealth\"]: number, -- Health that the enemy has when it spawns\n    [\"BaseSpeed\"]: number -- Speed that the enemy has when it spawns\n}\n</code></pre>"},{"location":"jTDF/#unit","title":"Unit","text":"<p>Note</p> <p>You can add new indecies to this object if needed</p> <pre><code>{\n    [\"CurLevel\"]: number, -- Current upgrade of the tower. Defaults to 1\n    [\"CurStats\"]: CTowerStats, -- Current stats used by the tower. Not recommended to change manually. Instead, use StatEffects to change stats\n    [\"CTowerID\"]: string, -- CTower index used by the tower. Don't change\n\n    [\"pathLabels\"]: {string}, -- Paths that this unit can target.\n    -- Warning: if 2 paths have different length, ranges with TargetType 1 will target enemies that have travelled the farthest on THEIR path!\n    -- Due to this behavior, it is adviced against having enemies cross 2 different paths at the same time, although if you don't mind this, you can.\n\n    [\"TowerID\"]: string, -- Unique ID that this unit has. You can use it to refer to jTDF.ActiveUnits, if such need is present\n    [\"Position\"]: vector, -- Position of the unit. Note that it's a vector, not Vector3\n    [\"Owner\"]: number, -- UserID of the player that placed that tower. You can manually set this value to nil in case where a neutral tower is needed\n    [\"Radius\"]: Radius -- Radius that the unit uses\n}\n</code></pre>"},{"location":"jTDF/#enemy","title":"Enemy","text":"<p>Note</p> <p>You can add new indecies to this object if needed</p> <pre><code>{\n    [\"CEnemyID\"]: string, -- CEnemy index used by the enemy. Don't change\n    [\"Speed\"]: number, -- Speed of the enemy, in studs/s. Defaults to CEnemy.BaseSpeed\n    [\"Health\"]: number, -- Current health of the enemy. When it reaches 0, if DestroyOnDeath is true, Enemy:Destroy() will be called. Defaults to CEnemy.BaseHealth\n    [\"EnemyID\"]: string, -- Unique ID that this enemy has. You can use it to refer to jTDF.ActiveEnemies, if such need is present\n    [\"CurrentPath\"]: Attachment, -- Path attachment that the enemy has already passed\n    [\"NextPath\"]: Attachment, -- Path attachment that the enemy is currently travelling to\n    [\"StartTime\"]: number, -- Time passed since CurrentPath has changed. Used for enemy position calculation\n    [\"DestroyOnDeath\"]: boolean, -- Whether :Destroy() will be called when health reaches 0\n    [\"LastHit\"]: Unit?, -- Last unit that has hit the enemy\n    [\"pathLabel\"]: string, -- Path used by the enemy. Cannot be changed.\n    [\"Frozen\"]: number? -- Determines whether the enemy is frozen. Use the Freeze and Unfreeze functions to change.\n}\n</code></pre>"},{"location":"jTDF/#radius","title":"Radius","text":"<p>Note</p> <p>You can add new indecies to this object if needed</p> <pre><code>{\n    [\"RadiusID\"]: string, -- Unique ID that this radius has. You can use it to refer to jTDF.ActiveRadii, if such need is present\n    [\"TowerID\"]: string?, -- Unique ID of the unit that this radius is bound to, if any\n    [\"LastThreats\"]: {Enemy}, -- Enemies in this radius since the last frame\n    [\"LastClose\"]: {Enemy}, -- Enemies that are within 5 studs from the border of this radius. Threats are not included in this table.\n    [\"Size\"]: number, -- Size of this radius in studs\n    [\"LockedTargets\"]: {[EnemyID]: Enemy}, -- Dictionary of enemies that this radius is currently locked onto\n    [\"CanLock\"]: boolean, -- Whether this radius locks onto enemies, or grabs the threat with best progress. True for lock, false for first enemy.\n    [\"MaxLockedTargets\"]: number, -- Maximum amount of targets this radius can have. Applies to both lockable and not lockable radii, despite the name.\n    [\"Position\"]: Vector2 -- Position of this radius, excluding height\n}\n</code></pre>"},{"location":"jTDF/#signals","title":"Signals","text":""},{"location":"jTDF/#unitplaced","title":".UnitPlaced","text":"<p><pre><code>-&gt; (Unit: Unit, Position: Vector3)\n</code></pre> Fires when a new unit is created</p>"},{"location":"jTDF/#unitdestroying","title":".UnitDestroying","text":"<p><pre><code>-&gt; (Unit: Unit)\n</code></pre> Fires when <code>:Destroy()</code> is called on any unit, 1 frame before it expires</p>"},{"location":"jTDF/#unitshot","title":".UnitShot","text":"<p><pre><code>-&gt; (Unit: Unit, Targets: {EnemyID})\n</code></pre> Fires when a unit calls its FireFunction</p>"},{"location":"jTDF/#unitchanged","title":".UnitChanged","text":"<p><pre><code>-&gt; (Unit: Unit)\n</code></pre> Fires when a unit is upgraded. It's functionality might be expanded in the future.</p>"},{"location":"jTDF/#enemykilled","title":".EnemyKilled","text":"<p><pre><code>-&gt; (Enemy: Enemy)\n</code></pre> Fires when enemy's health drops to 0, before <code>:Destroy()</code> is called</p>"},{"location":"jTDF/#enemyspawned","title":".EnemySpawned","text":"<p><pre><code>-&gt; (Enemy: Enemy)\n</code></pre> Fires when a new enemy is created</p>"},{"location":"jTDF/#enemyupdated","title":".EnemyUpdated","text":"<p><pre><code>-&gt; (Enemy: Enemy)\n</code></pre> Fires when an enemy's stats change (e.g. Speed)</p>"},{"location":"jTDF/#newradius","title":".NewRadius","text":"<p><pre><code>-&gt; (Radius: Radius)\n</code></pre> Fires when a new radius is created</p>"},{"location":"jTDF/#radiusdestroyed","title":".RadiusDestroyed","text":"<p><pre><code>-&gt; (Radius: Radius)\n</code></pre> Fires when <code>:Destroy()</code> is called on this radius</p>"},{"location":"jTDF/#unit_1","title":"Unit","text":""},{"location":"jTDF/#functions","title":"Functions","text":""},{"location":"jTDF/#define","title":".Define","text":"<p><pre><code>(ID: string?, CTower: CTower|{[CTowerID]: CTower})\n</code></pre> Defines a new CTower. ID is not used when CTower is a list</p>"},{"location":"jTDF/#new","title":".new","text":"<p>Note</p> <p>Some of this function's argument types are protected. If any of those arguments have an invalid type, the function will error.</p> <p>Protected arguments: Player, CTowerID, Position</p> <p><pre><code>(Player:Player?, CTowerID:string, Position:Vector3|vector, pathLabels: {string}?): Unit\n</code></pre> Creates a new unit object. If it's CTower is not yet defined, an error will be thrown</p>"},{"location":"jTDF/#destroy","title":":Destroy","text":"<pre><code>()\n</code></pre> <p>Destroys this unit object.</p> <p><code>Unit.Destroying</code> and <code>jTDF.Destroying</code> signals are called 1 frame before this unit is destroyed</p>"},{"location":"jTDF/#upgrade","title":":Upgrade","text":"<pre><code>(NewLevel)\n</code></pre> <p>Upgrades this unit. If next level doesn't have stats, upgrade will not happen, and unchanged CurLevel will be returned.</p>"},{"location":"jTDF/#signals_1","title":"Signals","text":""},{"location":"jTDF/#upgraded","title":".Upgraded","text":"<pre><code>-&gt; (CurUpgrade: number)\n</code></pre> <p>Fires when this unit is upgraded</p>"},{"location":"jTDF/#destroying","title":".Destroying","text":"<p><pre><code>-&gt; ()\n</code></pre> Fires when <code>:Destroy()</code> is called on this unit, 1 frame before it expires</p>"},{"location":"jTDF/#enemy_1","title":"Enemy","text":""},{"location":"jTDF/#functions_1","title":"Functions","text":""},{"location":"jTDF/#define_1","title":".Define","text":"<p><pre><code>(ID:string?, CEnemy:CEnemy|{[string]: CEnemy})\n</code></pre> Defines a new CEnemy. ID is not used when CEnemy is a list</p>"},{"location":"jTDF/#new_1","title":".new","text":"<p>Note</p> <p>Some of this function's argument types are protected. If any of those arguments have an invalid type, the function will error.</p> <p>Protected arguments: CEnemyID, pathLabel</p> <p><pre><code>(CEnemyID: string, pathLabel:string, PathPosition:{CurrentPath: Attachment, Progress:number}?): Enemy\n</code></pre> Creates a new enemy object. If it's CEnemy is not yet defined, an error will be thrown.</p> <p>Optional PathPosition argument determines where this enemy will be spawned. Example usage of this would be mystery enemies that spawn new random enemies on death.</p>"},{"location":"jTDF/#destroy_1","title":":Destroy","text":"<pre><code>()\n</code></pre> <p>Destroys this enemy object.</p> <p><code>Enemy.Destroying</code> and <code>jTDF.EnemyKilled</code> signals are called 1 frame before this enemy is destroyed</p>"},{"location":"jTDF/#damage","title":":Damage","text":"<pre><code>(Damage:number)\n</code></pre> <p>Damages this enemy</p>"},{"location":"jTDF/#changespeed","title":":ChangeSpeed","text":"<pre><code>(NewSpeed:number)\n</code></pre> <p>Warning</p> <p>This function will error with speeds of 0 or less. In those cases use :Freeze() and :Unfreeze() respectively.</p> <p>Changes speed of this enemy.</p>"},{"location":"jTDF/#freeze","title":":Freeze","text":"<p><pre><code>()\n</code></pre> Freezes this enemy in place.</p> <p>It should be noted that the original speed is not affected by this, and will be restored once this enemy is unfrozen.</p> <p>If you try to freeze a frozen enemy, the function will return silently.</p>"},{"location":"jTDF/#unfreeze","title":":Unfreeze","text":"<p><pre><code>()\n</code></pre> Unfreezes this enemy</p> <p>It should be noted that the original speed is not affected by this, and will remain the same when unfrozen.</p> <p>If you try to unfreeze an enemy that's not frozen, the function will return silently.</p>"},{"location":"jTDF/#signals_2","title":"Signals","text":""},{"location":"jTDF/#destroying_1","title":".Destroying","text":"<p><pre><code>-&gt; ()\n</code></pre> Fires when <code>:Destroy()</code> is called on this enemy, 1 frame before it expires</p>"},{"location":"jTDF/#gotdamaged","title":".GotDamaged","text":"<p><pre><code>-&gt; ()\n</code></pre> Fires when this enemy is damaged</p>"},{"location":"jTDF/#radius_1","title":"Radius","text":""},{"location":"jTDF/#functions_2","title":"Functions","text":""},{"location":"jTDF/#new_2","title":".new","text":"<p><pre><code>(InitPos:Vector2|vector, Size:number, Config:{}): Radius\n</code></pre> Creates a new radius</p>"},{"location":"jTDF/#fromid","title":".FromID","text":"<p><pre><code>(ID:string): Radius\n</code></pre> Returns a radius from its ID, if such a radius exists</p>"},{"location":"jTDF/#resize","title":":Resize","text":"<p><pre><code>(newRadius:number)\n</code></pre> Changes size of this radius. Currently, it just changes the Radius.Size property</p>"},{"location":"jTDF/#destroy_2","title":":Destroy","text":"<p><pre><code>()\n</code></pre> Destroys this radius object</p>"},{"location":"jTDF/#signals_3","title":"Signals","text":""},{"location":"jTDF/#destroying_2","title":".Destroying","text":"<pre><code>-&gt; ()\n</code></pre> <p>Fires 1 frame before this radius is destroyed</p>"},{"location":"jTDF/#targetchanged","title":".TargetChanged","text":"<pre><code>-&gt; (OldTargets:{}, NewTargets:{})\n</code></pre>"},{"location":"jTDF/#update","title":".Update","text":"<p>Warning</p> <p>This event should only be used by advanced users. Incorrect usage WILL lead to performance drawbacks.</p> <p><pre><code>-&gt; ()\n</code></pre> Forces a radius to update it's enemy list.</p> <p>Unlike other signals, it is used by firing it.</p> <p>Example usage of this signal would be if you know that radius has outdated enemy data, has already updated once, and now you need up-to-date enemy data THIS exact frame.</p> <p>It can also be used as a tool to instantly wake up a radius from throttle, for example when an enemy teleports into this radius from a distance larger than 5 studs.</p>"}]}